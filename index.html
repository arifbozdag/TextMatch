<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>To My Lovely Fianc√©e, Love of My Life, My Ay≈üenur!</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="To My Lovely Fianc√©e, Love of My Life, My Ay≈üenur! Please study your memory cards here. ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è">
  <!-- Favicon: put your image as icon.png next to this file -->
  <link rel="icon" type="image/png" href="icon.png">
  <!-- fallback emoji favicon (in case icon.png isn't present yet) -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üíñ</text></svg>">
  <style>
    :root{
      /* Layout + motion */
      --gap:12px; --radius:16px; --speed: 200ms;
      /* Card sizing (‚â•3 columns when space allows) */
      --card-min: 140px;
      --card-max: 260px;

      /* ‚ú® Bright pastel palette */
      --pink-50:#fff0f6; --pink-200:#ffd6e7; --pink-400:#ff9ac1; --pink-600:#ff5fa0;
      --blue-50:#eef6ff; --blue-200:#d6ecff; --blue-400:#98c9ff; --blue-600:#5aa7ff;
      --yell-50:#fffbe5; --yell-200:#fff4b8; --yell-400:#ffe27a; --yell-600:#ffd052;

      /* Base colors */
      --bg: linear-gradient(180deg, var(--pink-50), var(--blue-50));
      --panel: #ffffffd9;
      --panel-border:#ffe6f2;
      --text:#282a2e;
      --muted:#6b7280;

      /* Accents */
      --btn:#ffe0ee;
      --btn-border:#ffc2db;
      --btn-hover:#ffd8e8;
      --select:#7aa2ff;
      --select-shadow: rgba(122,162,255,.25);

      /* Sides */
      --A1:#ffe6f2; --A2:#ffd6e7; --A-border:#ff9ac1;
      --B1:#e9f3ff; --B2:#d6ecff; --B-border:#98c9ff;

      /* Match */
      --match:#dcfce7; --match-border:#34d399;
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:24px; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 5% -5%, rgba(255,218,239,.6), transparent 60%),
        radial-gradient(900px 500px at 105% 10%, rgba(214,236,255,.55), transparent 55%),
        radial-gradient(1000px 600px at 50% 120%, rgba(255,244,184,.6), transparent 60%),
        var(--bg);
      min-height:100svh;
    }
    .app{max-width:1100px;margin:0 auto;display:grid;gap:18px}
    .panel{
      background:var(--panel);
      border:1px solid var(--panel-border);
      border-radius:var(--radius);
      padding:16px;
      box-shadow:0 10px 35px rgba(255,182,216,.35);
    }
    .header{
      display:flex;gap:14px;align-items:center;flex-wrap:wrap;
      background:linear-gradient(135deg, var(--pink-200), var(--yell-200) 55%, var(--blue-200));
      border-radius:var(--radius);
      padding:14px;border:1px solid #ffeaf4;
      box-shadow: inset 0 0 0 1px #fff, 0 6px 18px rgba(255,182,216,.35);
    }
    .app-icon{
      width:64px;height:64px;border-radius:16px;object-fit:cover;
      border:3px solid #fff; box-shadow:0 6px 14px rgba(0,0,0,.08);
      background: #fff;
    }
    h1{margin:0;font-size:1.45rem}
    .tagline{margin:0;color:#444}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    input[type="text"]{
      flex:1 1 280px; max-width:420px; padding:10px 12px;
      border-radius:12px; border:1px solid #ffd2e4; background:#fff;
      color:var(--text); outline:none; box-shadow:0 2px 0 rgba(0,0,0,.02) inset;
    }
    input::placeholder{color:#9aa3b2}
    button{
      padding:10px 14px; border-radius:12px; border:1px solid var(--btn-border);
      background:linear-gradient(180deg, var(--btn), #ffe8f2);
      color:#3b3f45; cursor:pointer; transition:transform .06s ease, filter .15s ease;
      box-shadow:0 4px 10px rgba(255,182,216,.3);
    }
    button:hover{filter:brightness(1.06); background:linear-gradient(180deg, var(--btn-hover), #fff0f6)}
    button:active{transform:translateY(1px)}
    .stats{display:flex;gap:12px;flex-wrap:wrap;color:var(--muted);font-variant-numeric:tabular-nums}
    .empty-note{color:var(--muted);font-style:italic}
    .badge{font-size:12px;color:#6b7280;border:1px solid #ffe0ee;padding:3px 7px;border-radius:999px;background:#fff}
    /* Builder sizing */
    .panel.builder{overflow:hidden}
    .builder .list{
      display:grid; gap:8px; grid-template-columns:repeat(auto-fill, minmax(260px, 1fr));
      max-height:320px; overflow:auto; padding-right:4px;
    }
    .pair{
      background:#fff; border:1px solid #ffe0ee; padding:8px 10px; border-radius:12px;
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; min-width:0;
      box-shadow:0 3px 10px rgba(255,182,216,.25);
    }
    .pair .vals{min-width:0;flex:1 1 auto;display:flex;gap:8px;flex-wrap:nowrap}
    .pair .vals span{background:#fff7fb;padding:6px 8px;border-radius:8px;border:1px solid #ffe0ee;max-width:45%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .pair .vals .sep{color:#ff7fb4;max-width:10%;flex:0 0 auto}
    .pair .controls{flex:0 0 auto;display:flex;gap:8px;align-items:center}

    /* Game grid ‚Äî ‚â•3 columns when space allows, cards expand vertically */
    .grid{
      display:grid; gap:var(--gap);
      grid-template-columns:repeat(
        auto-fill,
        minmax(
          clamp(var(--card-min), calc((100% - (var(--gap) * 2)) / 3), var(--card-max)),
          1fr
        )
      );
      position:relative;
    }
    .card{
      position:relative; padding:14px 12px; min-height:92px;
      text-align:center; border-radius:16px; border:1px solid #ffd2e4;
      background:#fff; cursor:pointer;
      transition: box-shadow var(--speed) linear, transform .06s ease, border-color var(--speed) linear, background var(--speed) linear;
      user-select:none; display:flex; align-items:center; justify-content:center; flex-direction:column;
      box-shadow:0 10px 20px rgba(0,0,0,.04), 0 4px 10px rgba(255,182,216,.25);
    }
    .card:hover{transform:translateY(-1px)}
    .card[data-side="A"]{background:linear-gradient(180deg, var(--A1), var(--A2)); border-color: var(--A-border)}
    .card[data-side="B"]{background:linear-gradient(180deg, var(--B1), var(--B2)); border-color: var(--B-border)}
    .label{font-weight:700; line-height:1.3; display:block; white-space:normal; word-break:break-word; max-width:100%}
    .sub{display:block; margin-top:6px; font-size:12px; color:#555; opacity:.8}
    .card.selected{outline:2px solid var(--select); box-shadow:0 0 0 6px var(--select-shadow) inset}
    .card.matched{background:var(--match)!important; border-color:var(--match-border)!important}
    .card.disabled{opacity:.75; pointer-events:none}

    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  </style>
</head>
<body>
  <div class="app">
    <section class="header">
      <img class="app-icon" src="icon.png" alt="App Icon">
      <div>
        <h1>To My Lovely Fianc√©e, Love of My Life, My Ay≈üenur!</h1>
        <p class="tagline">Please study your memory cards here. ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</p>
      </div>
    </section>

    <!-- Deck Builder -->
    <section class="panel builder" aria-labelledby="builder-title">
      <h2 id="builder-title" style="margin-top:0;font-size:1.05rem">Deck Builder</h2>
      <div class="row" style="gap:10px">
        <input id="a-input" type="text" placeholder="Left (A) ‚Äî e.g., Country" />
        <input id="b-input" type="text" placeholder="Right (B) ‚Äî e.g., Capital" />
        <button id="add-btn" type="button">Add Pair</button>
        <button id="clear-btn" type="button" title="Clear list">Clear</button>
        <button id="save-btn" type="button" title="Save deck to this browser">Save</button>
        <button id="load-btn" type="button" title="Load last saved deck">Load</button>
      </div>
      <div id="pair-list" class="list" style="margin-top:10px"></div>
      <div class="row" style="margin-top:12px">
        <button id="start-btn" type="button">Start Game (Shuffle)</button>
      </div>
    </section>

    <!-- Game -->
    <section class="panel" aria-labelledby="game-title">
      <div class="row" style="justify-content:space-between">
        <h2 id="game-title" style="margin:0;font-size:1.05rem">Game</h2>
        <div class="stats">
          <div>Moves: <strong id="moves">0</strong></div>
          <div>Matches: <strong id="matches">0</strong></div>
          <div>Time: <strong id="time">00:00</strong></div>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="reset-btn" type="button">Reset</button>
        <button id="shuffle-btn" type="button">Shuffle (Animate)</button>
      </div>
      <p id="empty-note" class="empty-note">Add at least two pairs, then press ‚ÄúStart Game‚Äù.</p>
      <div id="grid" class="grid" role="grid" aria-live="polite" aria-label="Cards grid"></div>
      <div id="live" class="sr-only" aria-live="polite"></div>
    </section>
  </div>

  <script>
    // ---------- Helpers ----------
    const $ = sel => document.querySelector(sel);
    const speak = msg => { $('#live').textContent = msg; };
    const fmtTime = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
    const rng = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const shuffleInPlace = arr => { for (let i=arr.length-1; i>0; i--) { const j = Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; };

    // ---------- Deck (Pairs A/B) ----------
    /** pair: { id: string, A: string, B: string } */
    let pairs = []; // builder data

    function renderPairList() {
      const list = $('#pair-list');
      list.innerHTML = '';
      if (pairs.length === 0) {
        const hint = document.createElement('div');
        hint.className = 'empty-note';
        hint.textContent = 'No pairs yet. Add at least two A/B pairs.';
        list.appendChild(hint);
        return;
      }
      pairs.forEach(p => {
        const item = document.createElement('div');
        item.className = 'pair';

        const vals = document.createElement('div');
        vals.className = 'vals';
        const a = document.createElement('span'); a.textContent = p.A || '‚Äî';
        const sep = document.createElement('span'); sep.className = 'sep'; sep.textContent = '‚Üî';
        const b = document.createElement('span'); b.textContent = p.B || '‚Äî';
        vals.append(a, sep, b);

        const controls = document.createElement('div');
        controls.className = 'controls';
        const idBadge = document.createElement('span'); idBadge.className = 'badge'; idBadge.textContent = `id:${p.id}`;
        const del = document.createElement('button'); del.textContent = 'Delete';
        del.addEventListener('click', () => { pairs = pairs.filter(x => x.id !== p.id); renderPairList(); });
        controls.append(idBadge, del);

        item.append(vals, controls);
        list.appendChild(item);
      });
    }

    function addPair(aVal, bVal) {
      const A = aVal.trim(), B = bVal.trim();
      if (!A || !B) return;
      const id = crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + '-' + rng(1000,9999);
      pairs.push({ id, A, B });
      renderPairList();
      $('#a-input').value = ''; $('#b-input').value = ''; $('#a-input').focus();
    }

    $('#add-btn').addEventListener('click', () => addPair($('#a-input').value, $('#b-input').value));
    $('#a-input').addEventListener('keydown', e => { if (e.key==='Enter') { e.preventDefault(); $('#b-input').focus(); } });
    $('#b-input').addEventListener('keydown', e => { if (e.key==='Enter') { e.preventDefault(); addPair($('#a-input').value, $('#b-input').value); } });
    $('#clear-btn').addEventListener('click', () => { pairs = []; renderPairList(); });
    $('#save-btn').addEventListener('click', () => { localStorage.setItem('textmatch.ab.pairs', JSON.stringify(pairs)); speak('Deck saved'); });
    $('#load-btn').addEventListener('click', () => {
      const raw = localStorage.getItem('textmatch.ab.pairs'); if (!raw) return;
      try { pairs = JSON.parse(raw) || []; renderPairList(); speak('Deck loaded'); } catch {}
    });

    // ---------- Game State ----------
    /** card: { key: string, pairId: string, side: 'A'|'B', text: string, matched: boolean } */
    let deck = [];
    let selection = []; // up to 2 cards
    let moves = 0, matches = 0, timer = null, elapsed = 0, started = false;

    const grid = $('#grid');
    const movesEl = $('#moves'), matchesEl = $('#matches'), timeEl = $('#time'), emptyNote = $('#empty-note');

    function resetStats() {
      moves = 0; matches = 0; elapsed = 0; started = false;
      movesEl.textContent = '0'; matchesEl.textContent = '0'; timeEl.textContent = '00:00';
      if (timer) { clearInterval(timer); timer = null; }
    }

    function startTimer() {
      if (started) return; started = true;
      const t0 = Date.now() - (elapsed * 1000);
      timer = setInterval(() => { elapsed = Math.floor((Date.now() - t0)/1000); timeEl.textContent = fmtTime(elapsed); }, 500);
    }

    // Build deck: each pair becomes two open cards (A and B) with same pairId
    function buildDeckFromPairs() {
      if (pairs.length < 2) { alert('Please add at least two pairs.'); return null; }
      const cards = [];
      pairs.forEach(p => {
        cards.push({ key: p.id + '-A', pairId: p.id, side: 'A', text: p.A, matched: false });
        cards.push({ key: p.id + '-B', pairId: p.id, side: 'B', text: p.B, matched: false });
      });
      return shuffleInPlace(cards);
    }

    // FLIP animation for grid reorders
    function animateGridReorder(beforeRectsMap) {
      const children = Array.from(grid.children);
      children.forEach(el => {
        const id = el.dataset.key;
        const before = beforeRectsMap.get(id);
        const after = el.getBoundingClientRect();
        if (!before) return;
        const dx = before.left - after.left;
        const dy = before.top - after.top;
        if (dx || dy) {
          el.animate(
            [{ transform: `translate(${dx}px, ${dy}px)` }, { transform: 'translate(0, 0)' }],
            { duration: 280, easing: 'ease' }
          );
        }
      });
    }
    function snapshotChildRects() {
      const map = new Map();
      Array.from(grid.children).forEach(el => map.set(el.dataset.key, el.getBoundingClientRect()));
      return map;
    }

    function renderGrid() {
      grid.innerHTML = '';
      if (!deck.length) return;
      deck.forEach(card => {
        const cell = document.createElement('div');
        cell.className = 'card';
        cell.dataset.key = card.key;
        cell.dataset.side = card.side;
        cell.dataset.pair = card.pairId;
        if (card.matched) cell.classList.add('matched', 'disabled');

        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = card.text;
        const sub = document.createElement('span');
        sub.className = 'sub'; sub.textContent = `Side ${card.side}`;

        cell.append(label, sub);
        cell.setAttribute('role','button'); cell.setAttribute('tabindex','0');

        const act = () => handleCardSelect(cell);
        cell.addEventListener('click', act);
        cell.addEventListener('keydown', e => { if (e.key==='Enter' || e.key===' ') { e.preventDefault(); act(); } });

        grid.appendChild(cell);
      });
    }

    function handleCardSelect(cell) {
      const key = cell.dataset.key;
      const card = deck.find(c => c.key === key);
      if (!card || card.matched) return;

      startTimer();

      // Toggle selection
      if (cell.classList.contains('selected')) {
        cell.classList.remove('selected');
        selection = selection.filter(k => k !== key);
        return;
      }
      if (selection.length === 2) return;

      cell.classList.add('selected');
      selection.push(key);

      if (selection.length === 2) {
        moves++; movesEl.textContent = String(moves);

        const [k1, k2] = selection;
        const c1 = deck.find(c => c.key === k1);
        const c2 = deck.find(c => c.key === k2);

        // Only allow A-B matches with the same pairId (not A-A or B-B)
        const isMatch = c1 && c2 && c1.pairId === c2.pairId && c1.side !== c2.side;

        if (isMatch) {
          deck.find(c => c.key === k1).matched = true;
          deck.find(c => c.key === k2).matched = true;
          Array.from(grid.children).forEach(el => {
            if (el.dataset.key === k1 || el.dataset.key === k2) {
              el.classList.add('matched','disabled'); el.classList.remove('selected');
            }
          });
          matches++; matchesEl.textContent = String(matches);
          speak(`Matched pair ${c1.pairId}`);
          selection = [];

          if (matches === deck.length / 2) {
            clearInterval(timer);
            speak(`You win in ${moves} moves, time ${fmtTime(elapsed)}`);
            alert(`üéâ You win!\nMoves: ${moves}\nTime: ${fmtTime(elapsed)}`);
          }
        } else {
          const [el1, el2] = [k1, k2].map(k => Array.from(grid.children).find(e => e.dataset.key === k));
          setTimeout(() => {
            el1?.classList.remove('selected');
            el2?.classList.remove('selected');
            selection = [];
          }, 450);
        }
      }
    }

    function startGame() {
      const built = buildDeckFromPairs();
      if (!built) return;
      deck = built;
      resetStats();
      renderGrid();
      emptyNote.style.display = 'none';
      speak('Game started. Cards shuffled.');
    }

    function animateShuffle() {
      if (!deck.length) return;
      const before = snapshotChildRects();
      shuffleInPlace(deck);
      renderGrid();
      requestAnimationFrame(() => animateGridReorder(before));
      speak('Cards shuffled.');
    }

    function resetGame() {
      selection = [];
      deck.forEach(c => c.matched = false);
      deck = shuffleInPlace(deck);
      resetStats();
      renderGrid();
      emptyNote.style.display = deck.length ? 'none' : '';
      speak('Game reset.');
    }

    // Wire up
    $('#start-btn').addEventListener('click', startGame);
    $('#shuffle-btn').addEventListener('click', animateShuffle);
    $('#reset-btn').addEventListener('click', resetGame);

    // Warm start
    (function init() {
      try {
        const raw = localStorage.getItem('textmatch.ab.pairs');
        if (raw) pairs = JSON.parse(raw) || [];
      } catch {}
      renderPairList();
    })();
  </script>
</body>
</html>
